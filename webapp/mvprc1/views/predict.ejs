<!DOCTYPE html>
<html lang="en">
<head>
<!--meta name="viewport" content="width=device-width", initial-scale=1.0"-->
<!--meta http-equiv="X-UA-Compatible" content="ie=edge"-->

<link rel="stylesheet" type="text/css" href="css/styles.css">
<link rel="stylesheet" type="text/css" href="css/stylesnav.css">
<link rel="manifest" href="manifest.json" >
<script src="js/predict_bundle.js" defer></script>
<meta charset="UTF-8">

<title>Icy Bridge Detector</title>
<link rel="shortcut icon" type="image/png" href="imgs/rtp-aws-disolved-nose-16x16.png">
</head>


<body>

<header>

<div class="container">
  <img src="imgs/rtp-aws-disolved-nose-112x112.png" alt="logo" class="logo">

  <nav>
    <ul>
      <li><a href="index.ejs">App</a></li>
      <li><a href="bridge.ejs">Bridge</a></li>
      <li><a href="road.ejs">Road</a></li>
      <li><a href="both.ejs">Both</a></li>
      <li><a href="odd.ejs">Odd</a></li>
      <li><a href="face.ejs">Face</a></li>
      <li><a href="predict.ejs">Predict</a></li>
      <li><a href="about.ejs">About</a></li>
    </ul>
  </nav>
</div>
</header>

<!-- ---------------------------------------------------------------- -->



<div class="the_body">

	<H1> Predict </H1>

  <div>

      <label for="ver-select">Choose a version:</label>

      <select name="version" id="ver-select">
          <option value="">--Please choose an option--</option>
          <option value="0" selected>zero</option>
          <option value="1">one</option>
          <option value="2">two</option>
          <option value="3">three</option>
          <option value="4">four</option>
          <option value="5">five</option>
      </select>

  </div>

<script>

function onClickVersion(e) {

  var a = document.getElementById('face.ejs');
  a.click();

};




</script>

<!-- ---------------------------------------------------------------- -->



  <div>
    <H2> Cameras for Prediction </H2>
    <p> These are the cameras chosen for prediction. </p><br>
  </div>

  <div>
    <label class="switch">
      <input type="checkbox" id="slider">
      <span class="slider round"></span>
    </label>
    Actual Size
  </div>


  <div>
    <p>Select a camera feed:</p>
  </div>


  <div>
    <input type="radio" id="TOLL147_DAVIS_DR" name="feed_rb" value="TOLL147_DAVIS_DR" checked>
    <label for="TOLL147_DAVIS_DR">TOLL147_DAVIS_DR</label>
  </div>


  <div>
    <input type="radio" id="I40W_MM8" name="feed_rb" value="I40W_MM8">
    <label for="I40W_MM8">I40W_MM8</label>
  </div>

  <div>
    <input type="radio" id="I440_US64_Bypass" name="feed_rb" value="I440_US64_Bypass">
    <label for="I440_US64_Bypass">I440_US64_Bypass</label>
  </div>

  <div>
    <input type="radio" id="I26_BROADWAY" name="feed_rb" value="I26_BROADWAY">
    <label for="I26_BROADWAY">I26_BROADWAY</label>
  </div>


  <div>
     <input type="radio" id="TOLL147_HOPSON_RD" name="feed_rb" value="TOLL147_HOPSON_RD">
     <label for="TOLL147_HOPSON_RD">TOLL147_HOPSON_RD</label>
  </div>


  <div>
     <input type="radio" id="TOLL147_NC54" name="feed_rb" value="TOLL147_NC54">
     <label for="TOLL147_NC54">TOLL147_NC54</label>
  </div>


  <div>
     <input type="radio" id="TOLL54_APEXBBQ" name="feed_rb" value="TOLL54_APEXBBQ">
     <label for="TOLL54_APEXBBQ">TOLL54_APEXBBQ</label>
  </div>

  <div>
     <input type="radio" id="TOLL540_TOLL147" name="feed_rb" value="TOLL540_TOLL147">
     <label for="TOLL540_TOLL147">TOLL540_TOLL147</label>
  </div>

  <div>
     <input type="radio" id="TOLL540_NC55" name="feed_rb" value="TOLL540_NC55">
     <label for="TOLL540_NC55">TOLL540_NC55</label>
  </div>


  <div>
     <input type="radio" id="TOLL540_MCCRIMMON" name="feed_rb" value="TOLL540_MCCRIMMON">
     <label for="TOLL540_MCCRIMMON">TOLL540_MCCRIMMON</label>
  </div>


  <div>
     <input type="radio" id="I40_DAVIS_DR" name="feed_rb" value="I40_DAVIS_DR">
     <label for="I40_DAVIS_DR">I40_DAVIS_DR</label>
  </div>

















  <div>
   <input id='draw-btn' type='button' value='Draw' onclick='Draw()' />
   <input id='predict-btn' type='button' value='Predict' onclick='Predict()'/>
  </div>

  <div>

    <!-- crossorigin="anonymous" -->
    <!--    crossorigin="https://mvprc1.rtp-aws.org/predict.ejs" -->
    <!-- camera urls changed
        old way 
         https://tims.ncdot.gov/TIMS/cameras/viewimage.ashx?id=Toll147_DavisDr.JPG
        new way 
         https://eapps.ncdot.gov/services/traffic-prod/v1/cameras/images?filename=HillsboroughSt_BlueRidgeRd.jpg&t=1643830561936
    -->

    <img id="camera_feed" 
         class="camera_feed" 
         style="-webkit-user-select: none;
                margin: auto;
                background-color: hsl(0, 0%, 90%);
                max-width: 200px;
                max-height: 200px;
                transition: background-color 300ms;"
         src='https://eapps.ncdot.gov/services/traffic-prod/v1/cameras/images?filename=Toll147_DavisDr.JPG'>
    <canvas id='my_canvas'></canvas>

  </div>

  <div>
      <div id="predict_img"></div>

  </div>



  <div>
      <!-- Hidden canvas element. Used for taking snapshot of video. -->
      <canvas id='blob_canvas'></canvas>

  </div>

  <!-- download attribute forces the browser to download instead of navigating -->
  <!--
    These tests were done for download test three and four
    
    What is href='#'
   
    https://stackoverflow.com/questions/4855168/what-is-href-and-why-is-it-used

    1. Absolute path: move to another site like href="http://www.google.com"
    2. Relative path: move to another page within the site like herf ="defaultpage.aspx"
    3. Move to an element with a specified id within the page like href="#bottom"
    4. href="javascript:void(0)", it does not move anywhere.
    5. href="#" , it does not move anywhere but scroll on the top of the current page.
    6. href= "" , it will load the current page but some browsers causes forbidden errors.
    7. href= "#!", it goes to a non existant link

    Note: When we do not need to specified any url inside a anchor tag then use 
    <a href="javascript:void(0)">Test1</a>

    Note: The above note does not work for this example
    ie. this will not work:
          <a download="hello.txt" href='javascript:void(0)' id="link">Download</a>
    
    These will work:
      <a download="hello.txt" href='#' id="link">Download</a>
      <a download="hello.txt" href='#!' id="link">Download</a>

    Other posts in the thread mention that '#' is bad but '#!' is better.


  -->

  <div>
      <!-- for examples two, three and four -->
      <a download="hello.txt" href='#!' id="link">Download</a>
  </div>

  <div>
      <!-- for example five -->
      <img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">
  </div>



</div>

<script>

 function blobToString (b) {
   var u
   var x
   u = URL.createObjectURL(b)
   x = new XMLHttpRequest()
   // although sync, you're not fetching over internet
   x.open('GET', u, false);
   x.send();
   URL.revokeObjectURL(u);
   return x.responseText;
 }


function downloadTestOne () {
  console.log('download_test_one()')

  // var the_url = 'https://tims.ncdot.gov/TIMS/cameras/viewimage.ashx?id=I40_DavisDr.jpg';
  // This url fails with:
  // Access to fetch at
  //  'https://tims.ncdot.gov/TIMS/cameras/viewimage.ashx?id=I40_DavisDr.jpg'
  //  from origin 'https://mvprc1.rtp-aws.org' has been blocked by
  //  CORS policy: No 'Access-Control-Allow-Origin'
  //  header is present on the requested resource.
  //  If an opaque response serves your needs,
  //  set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
  //
  //  predict_bundle.js:255660 GET https://tims.ncdot.gov/TIMS/cameras/viewimage.ashx?id=I40_DavisDr.jpg
  //  net::ERR_FAILED 200

  var theUrl = 'https://upload.wikimedia.org/wikipedia/commons/7/77/Delete_key1.jpg'
  // This url works though:

  // Gets the response and returns it as a blob
  fetch(theUrl).then(res => res.blob()).then(blob => {
    // Here's where you get access to the blob
    // And you can use it for whatever you want
    // Like calling ref().put(blob)

    // Here, I use it to make an image appear on the page
    const objectURL = URL.createObjectURL(blob)
    const myImage = new Image()
    myImage.src = objectURL
    document.getElementById('predict_img').appendChild(myImage)
  }
  )
} // download test end


function download_test_two() {
  console.log('download_test_two()')

  // from this website
  // https://javascript.info/blob

  // Create a Blob from a string
  let a_blob0 = new Blob(['<html>...</html>'],{
      type: 'text/html'
  });
  // please note: the first argument must be an array [..]

  // create a Blob from a typed array and strings
  let hello = new Uint8Array([72, 101, 108, 108, 111]);
  // Hello in decimal Ascii
  let a_blob1 = new Blob([hello, ' ', 'world'],{
      type: 'text/plain'
  });

  // we can extract Blob slices with:
  // blob.slice([byteStart],[byteEnd],[contentType])
  //
  // byteStart - starting byte. defaul is 0
  // byteEnd - the last byte (exclusive, by default is till end)
  // contentType - the type of new blob, by default identicial as source
  //
  // The args are similar to array.slice, negative numbers are allowed too
  //
  // Blob objects are immutable
  // We can’t change data directly in a Blob, but we can slice parts of a
  // Blob, create new Blob objects from them, mix them into a new Blob
  // and so on.
  //
  // This behavior is similar to JavaScript strings: we can’t change a
  // character in a string, but we can make a new corrected string.

  /* These requiree in this class. */
  console.log("blob 0 is %o ", blobToString(a_blob0))
  console.log("blob 1 is %o ", blobToString(a_blob1))
} // download test end



function download_test_three() {
  console.log('download_test_three()')

  // from this website
  // https://javascript.info/blob

  // A Blob can be easily used as a URL for <a>, <img> or other tags, 
  // to show its contents.
  //
  // Thanks to type, we can also download/upload Blob objects, and the 
  // type naturally becomes Content-Type in network requests.
  //
  // Let’s start with a simple example. By clicking on a link you 
  // download a dynamically-generated Blob with hello world contents 
  // as a file:

  let blob = new Blob(["Hello, world!"], {type: 'text/plain'})

  link.href = URL.createObjectURL(blob)
  console.log(blobToString(blob))
} // download test end

function download_test_four() {
  console.log('download_test_four()')


  // TLDR. This will automatically download a blob as a file.  
  // The file will be named "hello.txt" and it will contain  
  // one line which says 'Hello from blob!'.

  
  // We can also create a link dynamically in JavaScript and simulate a 
  // click by link.click(), then downl  oad starts automatically.
  //
  // Here’s the similar code that causes user to download the dynamically 
  // created Blob, without any HTML:

  let link = document.createElement('a');
  link.download = 'hello.txt';

  let blob3 = new Blob(['Hello from blob!'], {type: 'text/plain'});

  link.href = URL.createObjectURL(blob3);

  console.log('link.href is %o', link.href)

  link.click();

  URL.revokeObjectURL(link.href);  

  // URL.createObjectURL takes a Blob and creates a unique URL 
  // for it, in the form blob:<origin>/<uuid>.
  //
  // That’s what the value of link.href looks like:

  console.log("blob 3 is %o ", blobToString(blob3))


  // For each URL generated by URL.createObjectURL the browser 
  // stores a URL → Blob mapping internally. So such URLs are short, 
  // but allow to access the Blob.

  // A generated URL (and hence the link with it) is only valid within 
  // the current document, while it’s open. And it allows to reference 
  // the Blob in <img>, <a>, basically any other object that expects a URL.

  // There’s a side-effect though. While there’s a mapping for a Blob, 
  // the Blob itself resides in the memory. The browser can’t free it.

  // The mapping is automatically cleared on document unload, so Blob 
  // objects are freed then. But if an app is long-living, then that 
  // doesn’t happen soon.

  // So if we create a URL, that Blob will hang in memory, even if not 
  // needed any more.

  // URL.revokeObjectURL(url) removes the reference from the internal 
  // mapping, thus allowing the Blob to be deleted (if there are no 
  // other references), and the memory to be freed.   Garbage collection.

  // In the last example, we intend the Blob to be used only once, 
  // for instant downloading, so we call URL.revokeObjectURL(link.href) 
  // immediately.

  // In the previous example with the clickable HTML-link, we don’t 
  // call URL.revokeObjectURL(link.href), because that would make the 
  // Blob url invalid. After the revocation, as the mapping is removed, 
  // the URL doesn’t work any more.



} // download test end



function download_test_five() {
  console.log('download_test_five()')

  // from https://javascript.info/blob#blob-to-base64
  //
  // Blob to base64
  // An alternative to URL.createObjectURL is to convert a Blob into a
  //  base64-encoded string.
  //
  // That encoding represents binary data as a string of ultra-safe “readable” 
  // characters with ASCII-codes from 0 to 64. And what’s more important – 
  // we can use this encoding in “data-urls”.
  //
  // A data url has the form data:[<mediatype>][;base64],<data>. We can 
  // use such urls everywhere, on par with “regular” urls.
  //
  // For instance, here’s a smiley:
  // 
  // <img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">
  //
  // The browser will decode the string and show the image: 
  //
  // To transform a Blob into base64, we’ll use the built-in FileReader object. 
  // It can read data from Blobs in multiple formats. In the next chapter 
  // we’ll cover it more in-depth.
  // 
  // Here’s the demo of downloading a blob, now via base-64:

  let link = document.createElement('a');
  link.download = 'hello.txt';

  let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

  let reader = new FileReader();
  reader.readAsDataURL(blob); // converts the blob to base64 and calls onload

  reader.onload = function() {
    link.href = reader.result; // data url
    link.click();
  };


  // Both ways of making a URL of a Blob are usable. But usually 
  // URL.createObjectURL(blob) is simpler and faster.
  //
  // URL.createObjectURL(blob)
  // o We need to revoke them if care about memory.
  // o Direct access to blob, no “encoding/decoding”
  //
  // 
  // Blob to data url
  // o No need to revoke anything.
  // o Performance and memory losses on big Blob objects for encoding.
  //
  // This download test code is using the second option here.


} // download test end



function download_test_six() {
  console.log('download_test_six()')

  // from https://javascript.info/blob#image-to-blob
  //
  // Image to blob
  // We can create a Blob of an image, an image part, 
  // or even make a page screenshot. That’s handy to upload it somewhere.
  //
  // Image operations are done via <canvas> element:
  // 
  // 1. Draw an image (or its part) on canvas using canvas.drawImage.
  //
  // 2. Call canvas method .toBlob(callback, format, quality) that creates 
  // a Blob and runs callback with it when done.
  // 
  // In the example below, an image is just copied, but we could 
  // cut from it, or transform it on canvas prior to making a blob:



  // take any image
  // the image i want is 'camera_feed'
  //
  // The Document method querySelector() returns the first Element within 
  // the document that matches the specified selector, or group of selectors. 
  // If no matches are found, null is returned.
  //
  // Note: The matching is done using depth-first pre-order traversal of the
  //  document's nodes starting with the first element in the document's markup 
  // and iterating through sequential nodes by order of the number of child nodes.
  //
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
  //
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById

  // orig let img = document.querySelector('img');
  let img = document.getElementById('camera_feed');

  // make <canvas> of the same size
  let canvas = document.createElement('canvas');
  canvas.width = img.clientWidth;
  canvas.height = img.clientHeight;

  let context = canvas.getContext('2d');

  // copy image to it (this method allows to cut image)
  context.drawImage(img, 0, 0);
  // we can context.rotate(), and do many other things on canvas

  // toBlob is async operation, callback is called when done
  canvas.toBlob(function(blob) {
    // blob ready, download it
    let link = document.createElement('a');
    link.download = 'example.png';

    link.href = URL.createObjectURL(blob);
    link.click();

    // delete the internal blob reference, to let the browser clear memory from it
    URL.revokeObjectURL(link.href);
  }, 'image/png');




} // download test end



function download_test_seven() {
  console.log('download_test_seven()')

  // From
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin

  // test six did not work.
  const imageUrl = "https://tims.ncdot.gov/TIMS/cameras/viewimage.ashx?id=I40_DavisDr.jpg";
  const container = document.querySelector(".the_body");

  function loadImage(url) {
    const image = new Image(200, 200);
    image.addEventListener("load",
      () => container.prepend(image)
    );

    image.addEventListener("error", () => {
      const errMsg = document.createElement("output");
      errMsg.value = `Error loading image at ${url}`;
      container.append(errMsg);
    });

    //image.crossOrigin = "anonymous";
    image.alt = "";
    image.src = url;
  }

  loadImage(imageUrl);


} // download test end




function Predict() {
    console.log("predict_btn: click() ");

    //download_test_one();
    //download_test_two();
    //download_test_three();
    //download_test_four();
    //download_test_five();
    //download_test_six();
    download_test_seven();

}
// predict_btn on click end



function Draw() {
// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes

  var img = document.getElementById('camera_feed')
  var cnvs = document.getElementById('my_canvas')
  cnvs.width = img.width
  cnvs.height = img.height

  cnvs.style.position = 'absolute'
  cnvs.style.left = img.offsetLeft + 'px'
  cnvs.style.top = img.offsetTop + 'px'

  // hmm, both settings are identical?
  console.log('width = %i', img.width)
  console.log('height = %i', img.height)
  console.log('offset width = %i', img.offsetWidth)
  console.log('offset height = %i', img.offsetHeight)

  var TOP = 0
  var BOTTOM = img.height
  var LEFT = 0
  var RIGHT = img.width

  console.log('TOP = %i', TOP)
  console.log('BOTTOM = %i', BOTTOM)
  console.log('LEFT = %i', LEFT)
  console.log('RIGHT = %i', RIGHT)

  var ctx = cnvs.getContext('2d')
  ctx.clearRect(0, 0, cnvs.width, cnvs.height)

  ctx.beginPath()
  ctx.moveTo(LEFT + 10, TOP + 10) // top left
  ctx.lineTo(RIGHT - 10, TOP + 10) // top right
  ctx.lineTo(RIGHT - 10, BOTTOM - 10) // bottom right
  ctx.lineTo(LEFT + 10, BOTTOM - 10) // bottom right
  ctx.lineTo(LEFT + 10, TOP + 10) // bottom right

  ctx.lineWidth = 3
  ctx.strokeStyle = '#00ff88'
  ctx.stroke()
}




</script>


<!-- display: inline        make horizontal
     display: block         default, vertical
     display: none          hidden
     visibility: hidden     also hidden
-->

</body>
</html>
